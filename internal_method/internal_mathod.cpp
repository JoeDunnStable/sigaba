//
/// @file internal_mathod.cpp
/// @package internal_method
//
/// @author Joseph Dunn on 8/17/19.
/// @copyright Joseph Dunn 2019.
//

/*
 * The MIT License
 *
 * Copyright 2019 Joseph Dunn.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <iostream>
using std::cout;
using std::endl;
using std::ostream;

#include <iomanip>
using std::setw;
using std::put_time;

#include <fstream>
using std::ofstream;

#include <sstream>
using std::ostringstream;

#include <vector>
using std::vector;

#include <random>
using std::uniform_int_distribution;
using std::random_device;

#include <chrono>
using std::chrono::system_clock;
#include <ctime>
using std::time_t;

#include <boost/program_options.hpp>
#include "internal_method.h"


int main(int argc, const char * argv[]) {
  using namespace boost::program_options;
  int size, n;
  
  options_description desc{"Generate wiring using the internal method"};
  
  desc.add_options()
  ("help,h", "display help message")
  ("size,s", value<int>(&size), "the number of contacts on the rotor")
  ("number,n",value<int>(&n)->default_value(1),"the number of rotors to generate");
  
  variables_map vm;
  try {
  store(parse_command_line(argc, argv, desc), vm);
  } catch(std::exception e) {
    cout << "Unable to parse command line arguments" << endl;
    cout << desc << endl;
    return 1;
  }
  notify(vm);
  
  if (vm.count("help")) {
    cout << desc << endl;
    return 0;
  }
  
  if (vm.count("size")) {
    if (size < 0) {
      cout << "size must be a positive integer" << endl;
      return 1;
    }
  } else {
    cout << "the size option is required" << endl;
    return 1;
  }
  
  if (n < 1) {
    cout << "the number of rotors to generate must be >=1" << endl;
  }
  
  ostringstream file_ss;
  std::chrono::system_clock::time_point now = system_clock::now();
  time_t now_c = std::chrono::system_clock::to_time_t(now);
  file_ss << "../output/rotor_wiring_" << size << "_" << n
          << put_time(localtime(&now_c),"_%Y%m%d_%H%M") << ".txt";

  cout << "Oukput written to file : " << file_ss.str() << endl;
  ofstream out(file_ss.str());
  
  random_device gen;
  
  vector< vector<int> > result;
  
  for (int i=0; i<n; ++i) {
    InternalMethod im(size, gen);
    vector<int> perm = im.get_perm();
    result.push_back(im.get_perm());
  }
  
  out << "// rotor wiring generated by the internal method" << endl;
  out << "// rotor size = " << size << endl << endl;
  out << "{" << endl;
  for (int i=0; i<n; ++i) {
    out << "{";
    for (int j=0; j<size; ++j) {
      out << result.at(i).at(j) << ((j==size-1) ? ((i==n-1)? "}":"},") : ",");
    }
    out << endl;
  }
  out << "}" << endl;
}
